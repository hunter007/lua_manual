C中的错误处理
===========

在内部，Lua使用C的`longjmp`处理错误（如果您用C++编译，Lua会使用异常；查看`LUAI_THROW`查看详情）。当Lua遇见错误（例如内存分配错误，或者类型错误）时，lua就抛出一个错误；，就是说，会执行一个长jump。受保护环境则使用`setjmp`来设置一个恢复点；任何错误都会跳转到最近的活跃的恢复点。

在一个C函数中，我们可以调用`lua_error`来抛出一个错误。

本API中的大部分函数都可能产生错误。例如内存分配错误。本文档会说明每一个函数是否会抛出错误。

如果在受保护环境之外发生错误，Lua就调用`panic`(lua_atpanic)，然后调用`abort`，然后退出宿主程序。我们的panic函数可以永不返回，以此避免退出（如在Lua之外，执行一个长跳转，到达自己的恢复点。）

正像名字所示的，panic函数是最后的机制。程序应避免使用它。一般来说，当Lua用一个Lua state调用C函数时，可以做任何可以在Lua state上做的事情，因为已经受保护了。然而，当C代码操作其他lua state时，应该只能用在不会抛出错误的API调用中。

panic函数运行时就像一个消息处理器一样([§2.3]())。尤其是，错误对象在栈顶的时候。然而这里没有栈空间的保护。要向栈中push值，panic函数应该先检查是否有可用空间。([§4.2]())
