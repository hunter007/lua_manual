元表和元方法
==========

Lua中的每个值都有一个`元表`，这个元表就是Lua中的一个普通的表。元表定义了在某种特定操作下原始值的行为。通过在元表中设置特定的字段，我们可以改变值操作的行为。例如，将非数字值应用到加法时，Lua会在这个值的元表中查找一个叫`__add`的函数，如果找到了，Lua调用这个函数来计算加法。

元表中每个事件的key是一个字符串，以两个下划线开始，key对应的值就是`元方法`。上面的例子中，key是`__add`，元方法是一个函数，这个函数执行加法。Unless stated otherwise, metamethods should be function values.

我们可以通过`getmetatable`函数查询任何值的元表。Lua再通过原始访问(`rawget`)在元表中查找元方法。所以，要获取值`o`的事件`ev`的元方法，Lua执行的操作等效于以下代码：

  rawget(getmetatable(o) or {}, "__ev")

我们可以用`setmetatable`函数替换表的元表，但是我们在Lua代码中**不能改变其他类型的元表**（除非通过debug库([§6.10](../ch6/6_10_the_debug_library.md))），我们应该使用** C API **来改变其他类型的元表。

表和`full userdata`有各自独立的元表（although multiple tables and userdata can share their metatables）。所有其他类型的值共享这个类型的同这个元表；也就是说，所有数字共享同一个元表，所有字符串共享同一个元表等等。默认情况下，值是没有元表的，但是`string`库给每个字符串都设置了元表（[§6.4](../ch6/6_4_string_manipulation/README.md)）.

元表可以控制对象在算术操作，位操作，大小比较，字符串连接，长度操作，函数调用和索引的行为。元表也可以定义一个函数，用于userdata或者表被垃圾回收的时候调用（[§2.5](./2_5/README.md)）

对于一元操作符(负号-、长度#、按位取反)，元方法在被调用的时候，会传入第二个操作数，和第一个操作数相等。这个额外的操作数仅仅为了简化Lua的内部(使一元操作符行为上类似于二元操作符)，在未来可能被移除（对大多数情况下，这个额外的操作数是不相干的、无用的。）

由元表控制的事件列表如下。每一个操作由相应的key说明。

  - **__add**: 加法操作。 如果加法的操作数不是数字（或者可以转成数字的字符串），Lua将尝试调用这个方法。首先，Lua检查第一个操作数（即使它是有效的）。如果这个操作数没有定义元方法`__add`，Lua将检查第二个操作数。如果Lua找到一个元方法，它会将两个操作数作为参数，调用那个元方法。这个调用的结果就是这个操作的结果。否则，会产生一个错误。
  - **__sub**: 减法操作。行为和 `__add`类似。
  - **__mul**: 乘法操作。行为和 `__add`类似。
  - **__div**: 除法操作(/)。行为和 `__add`类似。
  - **__mod**: 取模操作(%)。行为和 `__add`类似。
  - **__pow**: 求幂操作(^)。行为和 `__add`类似。
  - **__unm**: 一元运算符`-`。行为和 `__add`类似。
  - **__idiv**: 整除除号`//`。行为和 `__add`类似。
  - **__band**: 按位与`&`的操作。行为和 `__add`类似，但是如果操作数既不是整数也不可以强制转成整数([§3.4.3](../ch3/3_4_expressions/3_4_3_coercions_and_conversions.md)),Lua将尝试这个元方法。
  - **__bor**: 按位或`|`的操作。行为类似于`__band`。
  - **__bxor**: 按位异或`~`的操作。行为类似于`__band`。
  - **__bnot**: 按位取反，一元操作符`~`。行为类似于`__band`。
  - **__shl**: 左移操作`<<`。行为类似于`__band`。
  - **__shr**: 右移操作`>>`。行为类似于`__band`。
  - **__concat**: 字符串连接操作`..`。行为类似于算术加法。但是如果操作数既不是字符串也不是数字（数字总是可以转成字符串），Lua将尝试这个元方法。
  - **__len**: 字符串长度操作符`#`。如果对象不是一个字符串，Lua将尝试它的元方法。如果找到了元方法，Lua将这个对象作为元方法的参数，调用这个元方法，调用结果（总是当做一个返回结果）就是这个操作的结果。如果没有元方法，但是对象是一个表，Lua将使用表长度操作([§3.4.7](./ch3/3_4_expressions/3_4_7_the_length_operator.md))，否则Lua就抛出一个error。
  - **__eq**: 相等操作`==`。行为类似于算术加法，但是如果待比较的两个值是表或者`userdata`，它们一开始是不等的，Lua将尝试这个元方法。调用元方法的结果总是转成boolean。
  - **__lt**: 小于操作`<`。行为类似于算术加法。但是如果两个操作数既不是数字，也不是字符串的话，Lua将调用这个元方法。调用结果转成boolean。
  - **__le**: 小于等于操作`<=`。不像其它操作，这个操作符可以使用两个事件：首先，Lua在两个操作数中查找`__le`元方法，如果没有找到，Lua再尝试`__lt`方法，相当于`a <= b`和`not (b < a)`是一样的。结果总是boolean。（在以后的版本中，`__lt`事件可能会被移除；`__lt`也比`__le`慢。）
  - **__index**: 索引操作`table[key]`。 这个事件发生在table不是一个表，或者key不存在的时候。这个元方法在表中查找。

    除了名字，这个事件的元方法可以是一个函数或者一个表。如果是一个函数，表和key作为参数，调用这个函数。调用结果就是这个操作的结果。如果是一个表，用这个key索引这个表的结果就是最终结果（这个索引是regular，不是raw，因此可能触发另一个元方法）

  - **__newindex**: 索引赋值操作，相当于`table[key] = value`。和index事件一样，这个事件发生在表不是一个表，或者key不在表中的时候。这个元方法只存在于表中。

    和索引事件类似，这个元方法可以是一个函数或者一个表。如果是函数，表和key作为参数，调用这个函数。如果是个表，Lua用那个key和value对这个表执行赋值操作。（这个赋值是普通的，不是raw的，因此可能触发别的元方法）。

    如果`__newindex`存在，Lua就不再执行原生的赋值操作。（如果有必要，这个元方法也可以调用`rawset`来完成赋值。）

  - **__call**: 函数调用操作`func(args)`。这个事件发生在Lua尝试调用一个非函数的时候（func不是一个函数），Lua在 func上查询`__call`这个元方法。如果存在，func作为`__call`的第一个参数，args作为`__call`的其他参数，这个调用的结果就是这个函数的结果（`__call`是唯一允许返回多个结果的元方法）

最佳实践是：先将必要的元方法加入到元表中，然后将元表设置到一个对象上。实际中，`__gc`这个元方法在遵守这个order的时候才起作用。([§2.5.1](./2_5/2_5_1_metamethods.md))

因为元表就是一个普通的表，所以它可以包含任何字段，不仅仅是上面定义的事件名字。标准库中的一些函数（如`tostring`）使用了其他字段作为元方法。
